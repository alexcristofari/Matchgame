// Prisma Schema for MatchGame
// Using SQL Server (migrated from SQLite)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ==================== USER & AUTH ====================

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String?  // null for OAuth-only users
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  profile      Profile?
  integrations Integration[]
  favorites    Favorite[]
  interests    UserInterest[] // <--- New relation for recommendation engine
  likesGiven   Like[]        @relation("LikesGiven")
  likesReceived Like[]       @relation("LikesReceived")
  matchesAsUser1 Match[]     @relation("MatchUser1")
  matchesAsUser2 Match[]     @relation("MatchUser2")
  messagesSent Message[]
  reportsGiven Report[]      @relation("ReportsGiven")
  reportsReceived Report[]   @relation("ReportsReceived")
  blocksGiven  Block[]       @relation("BlocksGiven")
  blocksReceived Block[]     @relation("BlocksReceived")
  dislikesGiven Dislike[]    @relation("DislikesGiven")
  dislikesReceived Dislike[] @relation("DislikesReceived")
  refreshTokens RefreshToken[]
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ==================== PROFILE ====================

model Profile {
  id         String   @id @default(cuid())
  userId     String   @unique
  bio        String?
  birthDate  DateTime?
  location   String?
  latitude   Float?
  longitude  Float?
  lookingFor String   @default("both") // friendship, relationship, both
  photos     String   @default("[]") // JSON array of URLs
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  favoriteGame  String?
  favoriteMovie String?
  favoriteMusic String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ==================== INTEGRATIONS ====================

model Integration {
  id           String    @id @default(cuid())
  userId       String
  type         String    // steam, spotify, riot, tmdb, mal, discord
  externalId   String
  accessToken  String?
  refreshToken String?
  data         String    @default("{}") @db.Text // JSON data from API
  genres       String[]  @default([]) // Explicit genres column for easier querying
  syncedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
}

// ==================== FAVORITES ====================

model Favorite {
  id           String @id @default(cuid())
  userId       String
  category     String // games, music, movies, anime, books
  position     Int    // 1, 2, or 3
  itemId       String // External ID (Steam AppID, TMDB ID)
  itemName     String
  itemImageUrl String?
  
  // Relation to MediaItem (Optional, allowing gradual migration)
  mediaItemId  String?
  mediaItem    MediaItem? @relation(fields: [mediaItemId], references: [id])
  
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, position])
}

// ==================== MATCHING ====================

model Like {
  id          String   @id @default(cuid())
  fromUserId  String
  toUserId    String
  isSuperLike Boolean  @default(false)
  createdAt   DateTime @default(now())

  fromUser User @relation("LikesGiven", fields: [fromUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  toUser   User @relation("LikesReceived", fields: [toUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([fromUserId, toUserId])
}

model Dislike {
  id          String   @id @default(cuid())
  fromUserId  String
  toUserId    String
  createdAt   DateTime @default(now())

  fromUser User @relation("DislikesGiven", fields: [fromUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  toUser   User @relation("DislikesReceived", fields: [toUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([fromUserId, toUserId])
}

model Match {
  id                 String   @id @default(cuid())
  user1Id            String
  user2Id            String
  compatibilityScore Int      @default(0)
  scoreBreakdown     String   @default("{}") // JSON
  createdAt          DateTime @default(now())

  user1    User      @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  user2    User      @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  messages Message[]

  @@unique([user1Id, user2Id])
}

// ==================== CHAT ====================

model Message {
  id        String    @id @default(cuid())
  matchId   String
  senderId  String
  content   String
  readAt    DateTime?
  createdAt DateTime  @default(now())

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation(fields: [senderId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

// ==================== MODERATION ====================

model Report {
  id         String   @id @default(cuid())
  fromUserId String
  toUserId   String
  reason     String
  details    String?
  status     String   @default("pending") // pending, reviewed, resolved
  createdAt  DateTime @default(now())

  fromUser User @relation("ReportsGiven", fields: [fromUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  toUser   User @relation("ReportsReceived", fields: [toUserId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Block {
  id          String   @id @default(cuid())
  blockerId   String
  blockedId   String
  createdAt   DateTime @default(now())

  blocker User @relation("BlocksGiven", fields: [blockerId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  blocked User @relation("BlocksReceived", fields: [blockedId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([blockerId, blockedId])
}

// ==================== RECOMMENDATION ENGINE ====================

model MediaItem {
  id            String   @id @default(cuid())
  externalId    String   // Steam ID, TMDB ID, MAL ID
  type          String   // "GAME", "MOVIE", "ANIME", "MUSIC"
  title         String
  
  // Rich Metadata (Mirrors TCC CSV columns)
  genres        String   @default("[]") // JSON array: ["Action", "Sci-Fi"]
  keywords      String   @default("[]") // JSON array: ["space", "heist"]
  overview      String?  @db.Text // Description for TF-IDF
  developer     String?  // For Games
  publisher     String?  // For Games
  releaseDate   DateTime?
  popularity    Float?
  voteAverage   Float?   // 0-10 scale for quality score
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  favoritedBy   Favorite[]

  @@unique([externalId, type])
}

model UserInterest {
  id        String   @id @default(cuid())
  userId    String
  
  // Domain: "GAME", "MOVIE", "MUSIC", "ANIME"
  domain    String   
  
  // Type: "GENRE", "TAG", "DEVELOPER"
  type      String   
  
  // Value: "FPS", "Horror", "Valve", "Metallica"
  value     String   
  
  // Weight: 0.1 to 1.0 (Calculated based on frequency/ranking)
  weight    Float    @default(1.0)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, domain])
}
